# -*- coding: utf-8 -*-
"""VisionQuest.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YYJdlrT5htEhahQpqZSAjbx_dOhGdipV

# **ZYNGA HACKATHON SUBMISSION**
"""

pip install easyocr

from google.colab import drive
drive.mount('/content/drive')

"""## CODE SET [ 1 - 7 ]

## Generalised Approach for finding similarity in images
"""

import tensorflow as tf
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Input
from tensorflow.keras.models import Model
from sklearn.metrics.pairwise import cosine_similarity
import cv2
import numpy as np

def build_cnn(input_shape):
    input_img = Input(shape=input_shape)
    x = Conv2D(32, (3, 3), activation='relu')(input_img)
    x = MaxPooling2D((2, 2))(x)
    x = Conv2D(64, (3, 3), activation='relu')(x)
    x = MaxPooling2D((2, 2))(x)
    x = Flatten()(x)
    cnn_model = Model(inputs=input_img, outputs=x)
    return cnn_model


def extract_features(model, image):
    image = cv2.resize(image, (64, 64))
    image = image.astype('float32') / 255.0
    image = np.expand_dims(image, axis=-1)
    image = np.expand_dims(image, axis=0)
    return model.predict(image)


def calculate_similarity(feature1, feature2):
    return cosine_similarity(feature1, feature2)[0][0]


def load_image(file_path):
    return cv2.imread(file_path, cv2.IMREAD_GRAYSCALE)


def main():

    input_shape = (64, 64, 1)
    cnn = build_cnn(input_shape)

    main_image_path = input("Enter the path for the main image: ")
    main_image = load_image(main_image_path)
    if main_image is None:
        print("Failed to load the main image.")
        return

    test_image1_path = input("Enter the path for the first test image: ")
    test_image1 = load_image(test_image1_path)
    if test_image1 is None:
        print("Failed to load the first test image.")
        return

    test_image2_path = input("Enter the path for the second test image: ")
    test_image2 = load_image(test_image2_path)
    if test_image2 is None:
        print("Failed to load the second test image.")
        return

    feature_main = extract_features(cnn, main_image)
    feature_test1 = extract_features(cnn, test_image1)
    feature_test2 = extract_features(cnn, test_image2)

    similarity1 = calculate_similarity(feature_main, feature_test1)
    similarity2 = calculate_similarity(feature_main, feature_test2)

    print(f"Similarity percentages: [{similarity1 * 100:.2f}%, {similarity2 * 100:.2f}%]")

if __name__ == "__main__":
    main()

"""> **Approach to check similarity for all set from 1 to 7 is provided in a separate python file named as "Set1_to_Set7"**

## CODE SET 8

## GENERALISED CODE TO EXTRACT THE TOTAL WIN AMOUNT FROM THE GIVEN IMAGE
"""

import tensorflow as tf
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Input
from tensorflow.keras.models import Model

def build_cnn(input_shape):
    input_img = Input(shape=input_shape)
    x = Conv2D(32, (3, 3), activation='relu')(input_img)
    x = MaxPooling2D((2, 2))(x)
    x = Conv2D(64, (3, 3), activation='relu')(x)
    x = MaxPooling2D((2, 2))(x)
    x = Flatten()(x)
    x = Dense(128, activation='relu')(x)
    x = Dense(64, activation='relu')(x)
    cnn_model = Model(inputs=input_img, outputs=x)
    return cnn_model
input_shape = (224, 224, 3)
cnn_model = build_cnn(input_shape)
cnn_model.summary()

def extract_total_win(results):
    for result in results:
        text = result[1]
        if 'TOTAL WIN' in text:
            parts = text.split()
            # Check if the first part is a number
            if parts and parts[0].replace(',', '').isdigit():
                return parts[0]
    return None

"""### ***code for the result generation for SET 8 is provided in the separate file named "SET8". ***

## CODE SET 9

***IN SET9 our Task is to find the amount associated with "BET" so we desided to create a dataset for getting better results***

So we played the game and took screenshots while playing to create a dataset and then finally formed the output_directory to get our desired area of interest
"""

# Dataset Creation with Region of Interset

import os
import cv2
import easyocr
import numpy as np
import matplotlib.pyplot as plt
input_dir = '/content/drive/My Drive/without box'
output_dir = '/content/drive/My Drive/Zynga comp'
os.makedirs(output_dir, exist_ok=True)
reader = easyocr.Reader(['en'], gpu=False)
def bbox_distance(bbox1, bbox2):
    center1 = np.mean(bbox1, axis=0)
    center2 = np.mean(bbox2, axis=0)
    return np.linalg.norm(center1 - center2)
for image_name in os.listdir(input_dir):
    image_path = os.path.join(input_dir, image_name)
    img = cv2.imread(image_path)
    text_ = reader.readtext(img)
    threshold = 0.25
    bet_bbox = None
    closest_num = None
    min_dist = float('inf')
    for t_, t in enumerate(text_):
        bbox, text, score = t
        if score > threshold:
            top_left = tuple(map(int, bbox[0]))
            bottom_right = tuple(map(int, bbox[2]))
            if text.upper() == "BET":
                bet_bbox = bbox
            if any(c.isdigit() for c in text):
                cv2.rectangle(img, top_left, bottom_right, (0, 255, 0), 2)
                if bet_bbox:
                    dist = bbox_distance(bet_bbox, bbox)
                    if dist < min_dist:
                        min_dist = dist
                        closest_num = text
            else:
                cv2.rectangle(img, top_left, bottom_right, (0, 0, 255), 2)
    annotated_image_path = os.path.join(output_dir, image_name)
    cv2.imwrite(annotated_image_path, img)
    if closest_num:
        print(f"The closest numerical value to 'BET' in {image_name} is: {closest_num}")
    else:
        print(f"No numerical value found close to 'BET' in {image_name}.")

import tensorflow as tf
from tensorflow.keras import layers, models
def create_model(input_shape, num_classes):
    model = models.Sequential()
    model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=input_shape))
    model.add(layers.MaxPooling2D((2, 2)))
    model.add(layers.Conv2D(64, (3, 3), activation='relu'))
    model.add(layers.MaxPooling2D((2, 2)))
    model.add(layers.Conv2D(128, (3, 3), activation='relu'))
    model.add(layers.MaxPooling2D((2, 2)))
    model.add(layers.Flatten())
    model.add(layers.Dense(128, activation='relu'))
    model.add(layers.Dense(num_classes, activation='softmax'))
    return model
input_shape = (128, 128, 3)
num_classes = 1
model = create_model(input_shape, num_classes)
model.summary()
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

import os
import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.model_selection import train_test_split
dataset_dir = output_dir
image_paths = [os.path.join(dataset_dir, fname) for fname in os.listdir(dataset_dir) if fname.lower().endswith(('.png', '.jpg', '.jpeg'))]
labels = [0] * len(image_paths)
train_paths, val_paths, train_labels, val_labels = train_test_split(image_paths, labels, test_size=0.2, random_state=42)
print(f"Total images: {len(image_paths)}")
print(f"Training images: {len(train_paths)}")
print(f"Validation images: {len(val_paths)}")

import tensorflow as tf
from tensorflow.keras import layers, models
def create_model(input_shape):
    model = models.Sequential()
    model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=input_shape))
    model.add(layers.MaxPooling2D((2, 2)))
    model.add(layers.Conv2D(64, (3, 3), activation='relu'))
    model.add(layers.MaxPooling2D((2, 2)))
    model.add(layers.Conv2D(128, (3, 3), activation='relu'))
    model.add(layers.MaxPooling2D((2, 2)))
    model.add(layers.Flatten())
    model.add(layers.Dense(128, activation='relu'))
    model.add(layers.Dense(1, activation='sigmoid'))
    return model
input_shape = (128, 128, 3)
batch_size = 32
num_classes = 1
model = create_model(input_shape)
model.compile(optimizer='adam',
              loss='binary_crossentropy',
              metrics=['accuracy'])
model.summary()

steps_per_epoch = max(1, len(train_paths) // batch_size)
validation_steps = max(1, len(val_paths) // batch_size)
history = model.fit(
    custom_data_generator(train_paths, train_labels, batch_size, 128, 128),
    steps_per_epoch=steps_per_epoch,
    epochs=10,
    validation_data=custom_data_generator(val_paths, val_labels, batch_size, 128, 128),
    validation_steps=validation_steps
)
model.save('my_model.keras')

import seaborn as sns
import matplotlib.pyplot as plt
val_loss, val_accuracy = model.evaluate(val_generator, steps=validation_steps)

print(f"Validation loss: {val_loss:.4f}")
print(f"Validation accuracy: {val_accuracy:.4f}")